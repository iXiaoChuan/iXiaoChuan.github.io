
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>iOS高效图片处理01_底层图片IO技术优化 | 小川的博客·iXiaoChuan</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="iXiaoChuan">
    

    
    <meta name="description" content="说起图片处理，一直以来都是移动端开发的一个重点区域。基于移动端设备内存、CUP等硬件的局限性，图片处理在移动端的操作就显得异常需要细心，尤其是在iOS端的开发过程中，如果图片处理稍有不慎，就有可能会造成内存泄漏，严重的甚至直接崩溃或者被系统杀死。刚好前几天看的有个之前在做Linux的技术博主，写了一篇《关于图片IO操作的高效框架的练成》的技术博文，并且深入到了计算机底层的内存处理技术，进行了非常">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS高效图片处理01_底层图片IO技术优化">
<meta property="og:url" content="https://ixiaochuan.top/2018/04/13/iOS高效图片处理01/index.html">
<meta property="og:site_name" content="小川的博客·iXiaoChuan">
<meta property="og:description" content="说起图片处理，一直以来都是移动端开发的一个重点区域。基于移动端设备内存、CUP等硬件的局限性，图片处理在移动端的操作就显得异常需要细心，尤其是在iOS端的开发过程中，如果图片处理稍有不慎，就有可能会造成内存泄漏，严重的甚至直接崩溃或者被系统杀死。刚好前几天看的有个之前在做Linux的技术博主，写了一篇《关于图片IO操作的高效框架的练成》的技术博文，并且深入到了计算机底层的内存处理技术，进行了非常">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/1523343490248.jpg">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/CSAPP_C1_P1.png">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/align01.jpg">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/align02.jpg">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/fastImageCache2.png">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/1523520326722.jpg">
<meta property="og:image" content="https://simplecodesky.com/images/virtual-memory-from-csapp/1522750928874.jpg">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/15235197670131.gif">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/15235244516302.jpg">
<meta property="og:image" content="https://simplecodesky.com/images/ios-efficient-image-io/20160114201303391">
<meta property="og:updated_time" content="2018-08-14T08:44:48.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS高效图片处理01_底层图片IO技术优化">
<meta name="twitter:description" content="说起图片处理，一直以来都是移动端开发的一个重点区域。基于移动端设备内存、CUP等硬件的局限性，图片处理在移动端的操作就显得异常需要细心，尤其是在iOS端的开发过程中，如果图片处理稍有不慎，就有可能会造成内存泄漏，严重的甚至直接崩溃或者被系统杀死。刚好前几天看的有个之前在做Linux的技术博主，写了一篇《关于图片IO操作的高效框架的练成》的技术博文，并且深入到了计算机底层的内存处理技术，进行了非常">
<meta name="twitter:image" content="https://simplecodesky.com/images/ios-efficient-image-io/1523343490248.jpg">

    
    <link rel="alternative" href="/atom.xml" title="小川的博客·iXiaoChuan" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="小川的博客·iXiaoChuan" title="小川的博客·iXiaoChuan"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="小川的博客·iXiaoChuan">小川的博客·iXiaoChuan</a></h1>
				<h2 class="blog-motto">零散知识整理、技术脉络总结、工作人生规划</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/usedapp">常用软件</a></li>
					
					<li>
 					
						<form class="search" action="http://ixiaochuan.top" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 10090999781559433000 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/04/13/iOS高效图片处理01/" title="iOS高效图片处理01_底层图片IO技术优化" itemprop="url">iOS高效图片处理01_底层图片IO技术优化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="iXiaoChuan" target="_blank" itemprop="author">iXiaoChuan</a>
		
  <p class="article-time">
    <time datetime="2018-04-13T01:45:27.000Z" itemprop="datePublished"> 发表于 04-13-2018</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#加载图片的底层操作原理"><span class="toc-number">1.</span> <span class="toc-text">加载图片的底层操作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化"><span class="toc-number">1.1.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件读取-资源消耗？"><span class="toc-number">2.</span> <span class="toc-text">文件读取,资源消耗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优化"><span class="toc-number">2.1.</span> <span class="toc-text">如何优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存在的问题"><span class="toc-number">2.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li></ol>
		
		</div>
		
		<a id="more"></a>
<p>说起图片处理，一直以来都是移动端开发的一个重点区域。基于移动端设备内存、CUP等硬件的局限性，图片处理在移动端的操作就显得异常需要细心，尤其是在iOS端的开发过程中，如果图片处理稍有不慎，就有可能会造成内存泄漏，严重的甚至直接崩溃或者被系统杀死。刚好前几天看的有个之前在做Linux的技术博主，写了一篇《关于图片IO操作的高效框架的练成》的技术博文，并且深入到了计算机底层的内存处理技术，进行了非常全面的分析，看完感觉写的很有水平，就转载了博主的原文，自己也进一步加深一下关于图片操作在iOS端的一些原理问题。原文如下:</p>
<h2 id="加载图片的底层操作原理"><a href="#加载图片的底层操作原理" class="headerlink" title="加载图片的底层操作原理"></a>加载图片的底层操作原理</h2><p>正常状态下，下载一张图片，并且将其显示到屏幕上的UIImageView上，可以如下操作(Objective-C):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSURL* url = [NSURL URLWithString:@&quot;http://img3.duitang.com/uploads/item/201404/23/20140423122142_WTk3N.jpeg&quot;];</div><div class="line"> __weak typeof(self) weakSelf = self;</div><div class="line"> NSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithRequest:[[NSURLRequest alloc] initWithURL:url]</div><div class="line">                                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</div><div class="line">                                                                  UIImage* image = [UIImage imageWithData:data];</div><div class="line">                                                                  dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                                      [weakSelf.imageView setImage:image];</div><div class="line">                                                                  &#125;);</div><div class="line">                                                              &#125;];</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<p>运行上面的代码，然后通过内存检测工具Instrument查看CPU的消耗情况:</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/1523343490248.jpg" alt="e.g."></p>
<ol>
<li>应用程序使用了 CA::Render::copy_image， 这是因为 Core Animation 在图像数据非字节对齐的情况下渲染前会先拷贝一份图像数据，当我们使用 imageWithContentsOfFile 也会发生这种情况。</li>
<li>应用程序使用了 CA::Render::create_image_from_provider， 这个方法实际上是对图片进行解码，原因是 UIImage 在加载的时候实际上并没有对图片进行解码，而是延迟到图片被显示或者其他需要解码的时候。这种策略节约了内存，但是却会在显示的时候占用大量的主线程CPU时间进行解码，导致界面卡顿。</li>
</ol>
<p>那么如何解决上述两个问题，我们使用 FastImageCache 这个第三方库加载图片，官方Demo一开始的 FICDPhoto 加载图片的方法为使用 imageWithContentsOfFile， 这会导致 CA::Render::copy_image 的图像数据拷贝，所以更改为以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)sourceImage &#123;</div><div class="line">    __block UIImage *sourceImage = [UIImage imageWithContentsOfFile:[_sourceImageURL path]];</div><div class="line">    if (!sourceImage) &#123;</div><div class="line">        pthread_mutex_lock(&amp;_mutex);</div><div class="line">        NSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithRequest:[[NSURLRequest alloc] initWithURL:_sourceImageURL]</div><div class="line">                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</div><div class="line">                                            sourceImage = [UIImage imageWithData:data];</div><div class="line">                                            pthread_cond_signal(&amp;_signal);</div><div class="line">                                            pthread_mutex_unlock(&amp;_mutex);</div><div class="line">                                        &#125;];</div><div class="line">        [task resume];</div><div class="line">        pthread_cond_wait(&amp;_signal, &amp;_mutex);</div><div class="line">        pthread_mutex_unlock(&amp;_mutex);</div><div class="line">    &#125;</div><div class="line">    return sourceImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当图片被渲染到 ImageView 的时候，利用 Instrument 查看并没有发生 CA::Render::copy_image 和 CA::Render::create_image_from_provider 的情况。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>FastImageCache是如何解决上述两个问题的？<br>先看第一个问题，为何 Core Animation 在渲染之前要拷贝一份数据呢？<br>在此之前，我们先看一些计算机系统的理论知识，等看完后再回头看看，答案便更加明朗了。<br>我们都知道，图片说白了就是一段字节数据所组成的文件数据而已，也就是说我们把图片显示到界面上，不过是把一堆字节加载到 CPU 的寄存器当中，然后通过 GPU 将字节变成红(R)、绿(G)、蓝(B)的三原色的数组，然后通过界面显示出来(也就是我们所说的渲染)。所以，我们先了解一下，字节数据是如何通过内存加载到 CPU 的。</p>
<p>学过计算机操作系统的我们都知道，所有的字节数据都是通过总线来传送的，总线连接着 CPU 到主存，主存到磁盘等主要硬件设备的传输路线，而主要的传输单位就是字(word)，由于数字信号分为高频和低频，所以我们的计算机信号只有 0 和 1 两种来区分，所以我们采用了二进制的数据形式来表述数据，因此信号的量化精度一般以比特（bits）来衡量，这就是字节数据在总线中传输的本质。</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/CSAPP_C1_P1.png" alt="img"></p>
<p>而 64 位系统当中，字(word) 是 8 个字节的大小。<br>内存的存储单元被称为块(Chunk)，而块的大小是硬件设备自定的，大多数文件系统都是基于块设备，即存取规定数据块的硬件抽象层。<br>例如32位的文件系统中，高速缓存(Cache)以4个字节块的大小为数据传输单位传送数据到 CPU 当中，而下图就说明了该过程中 CPU 如何以4字节内存访问粒度访问4字节的数据：</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/align01.jpg" alt="img"></p>
<p>如果我们获取的数据为未对齐的4个字节，CPU 就会执行额外的工作去访问数据：加载两个字节块(Chunk)的数据，移出不需要的字节，然后将它们组合在一起，以便从内存中获取正确的数据，然而这个过程肯定会降低性能并浪费CPU周期。</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/align02.jpg" alt="img"></p>
<p>所以我们存储数据的时候，需要进行 字节对齐(Byte Alignment) 操作，其实称为字节块对齐更为合适，也就是说我们所取的数据，都以上图第一种的形式在内存中读写，避免发生第二种情况，这样就能节省 CPU 周期，加快存取速度。</p>
<p>再回头看看当我们从内存中读取图片数据的时候，也是一堆的字节块，如果图像字节并没有经过任何处理，那么就会出现以下情况：</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/fastImageCache2.png" alt="img"></p>
<p>当我们数据传输的时候，以字来传输，而从存储设备中读取内存却以块为单位，所以从内存读取到的图像数据势必会带上其他”杂质字节”，所以便发生了如上图所示的–“通常情况”。但是 GPU 所需要的数据，是图片正确完整的字节数据，而如果不处理这些”杂质字节”，就会影响图像生成。所以 Core Animation 就需要把”杂质字节”去除，然后变成我们所需要的–”完整状态”。所以，并不是 Core Animation 才需要这么做，而是我们接触到的所有图像处理相关的操作，都必须这么做，不然图像数据就乱了，只不过 Core Animation 帮我们封装了这些底层处理而已。</p>
<p>所以，<font color="red">通过以上的图片内存原理的分析我们知道，在对图片进行读取操作的时候，为了节省开销应该进行字节对齐的操作。</font></p>
<p><strong>对于高速缓存(Cache)来说，存取都是以字节块的形式，而块的大小跟 CPU 的高速缓存存储器有关，ARMv7是 32 Byte，A9是 64 Byte，在 A9 下CoreAnimation 应该是按 64 Byte(也就是8个字，8Byte/字) 作为一块数据去读取、存储和渲染，让图像数据对齐64 Byte 就可以避免CoreAnimation再拷贝一份数据。能节约使用的内存和进行copy的时间。(因为图片存入的时候已经对齐过了，获取的时候自然也是字节对齐的)，</strong></p>
<p>如何字节块对齐避免 Core Animation 进行图像数据复制？以下是代码形式进行实操：</p>
<ul>
<li><font size="3" color="#3194d5">计算图像所需字节大小</font>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/** FICImageTable.m */</div><div class="line"></div><div class="line">CGSize pixelSize = [_imageFormat pixelSize]; // 想要展示的图片大小</div><div class="line">NSInteger bytesPerPixel = [_imageFormat bytesPerPixel]; // 该图像格式中的字节每像素， 例如 FICImageFormatStyle32BitBGRA 为32位4个字节</div><div class="line">_imageRowLength = (NSInteger)FICByteAlignForCoreAnimation((size_t) (pixelSize.width * bytesPerPixel));</div><div class="line">_imageLength = _imageRowLength * (NSInteger)pixelSize.height;</div></pre></td></tr></table></figure>
<p>通过 FICByteAlignForCoreAnimation 函数对图片数据进行字节对齐然后计算， 得到 _imageRowLength 图像每行的字节数， 图像所需字节 = 图像的高度 * _imageRowLength(字节块对齐的图像每行字节数)。</p>
<ul>
<li><font size="3" color="#3194d5">通过实际图像每行所需的字节进行字节块对齐</font>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> size_t <span class="title">FICByteAlignForCoreAnimation</span><span class="params">(<span class="keyword">size_t</span> bytesPerRow)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> FICByteAlign(bytesPerRow, <span class="number">64</span>); <span class="comment">// 跟 CPU 的高速缓存器有关</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font size="3" color="#3194d5">让 width 成为 alignment 的倍数计算</font>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> size_t <span class="title">FICByteAlign</span><span class="params">(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> alignment)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((width + (alignment - <span class="number">1</span>)) / alignment) * alignment;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font size="3" color="#3194d5">创建Entry所对应的 Chunk，而 Chunk 是页对齐的</font>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置每一个 entry 的字节长度，因为除了图像数据外，fastImageCache 还额外为图像添加了两个 UUID 的 32 个字节</span></div><div class="line">_entryLength = (NSInteger)FICByteAlign(_imageLength + <span class="keyword">sizeof</span>(FICImageTableEntryMetadata), (<span class="keyword">size_t</span>) [FICImageTable pageSize]);</div><div class="line"></div><div class="line">entryData = [[FICImageTableEntry alloc] initWithImageTableChunk:chunk bytes:mappedEntryAddress length:(<span class="keyword">size_t</span>) _entryLength];</div></pre></td></tr></table></figure>
<p>为什么要进行页对齐？因为对于磁盘来讲，磁盘中的字节块大小就是页，因为分页就是磁盘和物理内存的存储方式，这样做就可以节省读取 entryData时CPU周期，这是跟字节对齐一样的道理。</p>
<ul>
<li><font size="3" color="#3194d5">通过_imageRowLength来创建位图，由于图像字节块已经对齐， 避免 CA::Render::copy_image 图像数据的拷贝发生了。</font>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 创建 CGDataProviderRef 用于图像上下文创建，提供图像数据和数据结构的 Release 函数</div><div class="line">CGDataProviderRef dataProvider = CGDataProviderCreateWithData((__bridge_retained void *)entryData, [entryData bytes], [entryData imageLength], _FICReleaseImageData);</div><div class="line"></div><div class="line">CGSize pixelSize = [_imageFormat pixelSize]; // 想要展示的图片大小</div><div class="line">CGBitmapInfo bitmapInfo = [_imageFormat bitmapInfo]; // 位图数据的信息，例如是大小端，计算位数等</div><div class="line">NSInteger bitsPerComponent = [_imageFormat bitsPerComponent]; // 每个组成的位数，32位RGBA、RGB和8位Gray都为8bit，而16位的RGB为5bit</div><div class="line">NSInteger bitsPerPixel = [_imageFormat bytesPerPixel] * 8; // bit每个像素</div><div class="line">CGColorSpaceRef colorSpace = [_imageFormat isGrayscale] ? CGColorSpaceCreateDeviceGray() : CGColorSpaceCreateDeviceRGB();</div><div class="line"> </div><div class="line">CGImageRef imageRef = CGImageCreate((size_t) pixelSize.width, (size_t) pixelSize.height, (size_t) bitsPerComponent, (size_t) bitsPerPixel,(size_t) _imageRowLength, colorSpace, bitmapInfo, dataProvider, NULL, false, (CGColorRenderingIntent)0);</div><div class="line">CGDataProviderRelease(dataProvider);</div><div class="line">CGColorSpaceRelease(colorSpace);</div></pre></td></tr></table></figure>
<h2 id="文件读取-资源消耗？"><a href="#文件读取-资源消耗？" class="headerlink" title="文件读取,资源消耗？"></a>文件读取,资源消耗？</h2><p>当我们从磁盘当中获取图像数据时，必须调用read()函数来从磁盘中读取图像字节数据，那么一起看看 read() 函数的调用过程:<br><img src="https://simplecodesky.com/images/ios-efficient-image-io/1523520326722.jpg" alt="img"></p>
<p>图3-1展示了当应用程序调用read()函数的时候：</p>
<ol>
<li>CPU 接受到中断信号，进入了内核模式。</li>
<li>内核模式中利用内核模式程序访问高速缓存(Cache)，查看高速缓存是否存在图像数据，如果有则返回，没有则继续访问物理内存。</li>
<li>内核模式程序读取物理内存，查看是否存在对应的物理页(磁盘跟物理内存的存储方式都是以分页的方式划分数据块的，通常64位系统为 4KB/页)，如果存在则将物理页数据读取，返回相对应图像数据所在的物理页，没有则发生异常行为(页错误)。</li>
<li>缺页异常处理程序访问磁盘，找到磁盘中对应的图像数据加载成磁盘页， 并将磁盘页作为新页替换物理内存中的物理页，然后将物理页数据作为字节块缓存到高速缓存当中。</li>
<li>异常处理程序发出中断信号将控制返回内核程序，内核程序再次加载高速缓存字节块放置到内核缓冲区。</li>
<li><p>由于内核程序跟用户程序的内存地址空间是完全不同的，所以对于虚拟内存来讲，内核程序要将内核缓冲区中的数据字节进行一次拷贝，才能返回给用户程序。</p>
<p>(PS: 用户程序跟内核程序的概念中，可能两者都为同一程序，只是由于CPU切换模式而转换，也有可能是两个不同的程序)</p>
</li>
</ol>
<p>CPU 读取内存页过程:<br><img src="https://simplecodesky.com/images/virtual-memory-from-csapp/1522750928874.jpg" alt="img"></p>
<p>当然，上面的分析是针对逻辑层面跟硬件层面的讲解，实际上软件层面上，对于一次磁盘请求如下：</p>
<p>图3-2显示了 read 系统调用在核心空间中所要经历的层次模型。从图中看出， 对于磁盘的一次读请求:</p>
<ol>
<li>首先经过虚拟文件系统层（vfs layer）</li>
<li>其次是具体的文件系统层（例如 ext2）</li>
<li>接下来是 cache 层（page cache 层）</li>
<li>通用块层（generic block layer）</li>
<li>IO 调度层（I/O scheduler layer）</li>
<li>块设备驱动层（block device driver layer）</li>
<li>最后是物理块设备层（block device layer）</li>
</ol>
<p>图3-2 read 系统调用在核心空间中的处理层次</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/15235197670131.gif" alt="img"></p>
<p>(对于这部分目前先留个悬念，以后分享在详细讲解文集系统)</p>
<p>通过上面对read()函数的分析，我们知道从磁盘中读取一次文件的操作是非常繁碎而且非常消耗资源的(特别是大文件)，而且由于物理内存和高速缓存的资源是有限的，当我们不再访问图像数据的时候，图像数据就会被当做牺牲页换出物理内存和高速缓存，当我们应用程序后面再次read()访问的时候，还得再次重新走上述流程。<br>那么这个时候我们可以怎么优化来加快我们对图片的IO呢？</p>
<h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><p>对于我们iOS这种封闭系统来讲，优化手段其实很有限，因为我们不能直接操作内核，但是不是就无法优化呢？而操作系统为我们提供了一个用户级的内核函数mmap/ummap，这是一对实现内存映射做法的函数，那么内存映射能为我们读写文件的操作带来什么？<br>答案就是优化了上述流程的 1 和 6 中所产生的内存拷贝过程，我们首先来看看内存映射是什么。</p>
<p>操作系统通过将一个虚拟内存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。</p>
<p>下图展示了内存映射的做法：</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/15235244516302.jpg" alt="img"></p>
<p>下图展示了内存映射区域在进程中的位置：</p>
<p><img src="https://simplecodesky.com/images/ios-efficient-image-io/20160114201303391" alt="img"></p>
<p>当磁盘文件通过内存映射到应用程序的时候，是直接跟用户空间的地址相关联的，也就是说当我们读取磁盘文件数据的时候，CPU 不用在切换用户空间和内核空间，随之字节拷贝也不会再发生，所有读取操作都能在用户空间中进行。</p>
<p>好了，说了这么多，具体做法怎么做呢？<br>在 FastImageCache 当中，创建 Chunk 实现文件中对一个 Chunk 内存区域部分进行内存映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// FICImageTableChunk.m</div><div class="line"></div><div class="line">- (instancetype)initWithFileDescriptor:(int)fileDescriptor index:(NSInteger)index length:(size_t)length &#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self != nil) &#123;</div><div class="line">        _index = index;</div><div class="line">        _length = length;</div><div class="line">        _fileOffset = _index * _length;</div><div class="line">        // 通过内存映射设置为共享内存文件</div><div class="line">        _bytes = mmap(NULL, _length, (PROT_READ|PROT_WRITE), (MAP_FILE|MAP_SHARED), fileDescriptor, _fileOffset);</div><div class="line"></div><div class="line">        if (_bytes == MAP_FAILED) &#123;</div><div class="line">            NSLog(@&quot;Failed to map chunk. errno=%d&quot;, errno);</div><div class="line">            _bytes = NULL;</div><div class="line">            self = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就有一个疑问了，通过FastImageCache 架构分析文章中知道，一个图片文件应该对应为一个Entry才对呀，为什么现在内存映射要映射Chunk呢？<br><br>因为内存映射文件越大越有效果呀，不然小数据通过read()函数直接进入内核拷贝字节这种做法就跟内存映射没有对比了。</p>
<p>为了让映射文件更大， FastImageCache 甚至直接在存储图片的时候就直接将图片解码了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">- (void)setEntryForEntityUUID:(NSString *)entityUUID sourceImageUUID:(NSString *)sourceImageUUID imageDrawingBlock:(FICEntityImageDrawingBlock)imageDrawingBlock &#123;</div><div class="line">    if (entityUUID != nil &amp;&amp; sourceImageUUID != nil &amp;&amp; imageDrawingBlock != NULL) &#123;</div><div class="line">        [_lock lock]; // 递归锁</div><div class="line">        // 创建 Entry</div><div class="line">        NSInteger newEntryIndex = [self _indexOfEntryForEntityUUID:entityUUID];</div><div class="line">        if (newEntryIndex == NSNotFound) &#123;</div><div class="line">            newEntryIndex = [self _nextEntryIndex];</div><div class="line">            </div><div class="line">            if (newEntryIndex &gt;= _entryCount) &#123;</div><div class="line">                // Determine how many chunks we need to support new entry index.</div><div class="line">                // Number of entries should always be a multiple of _entriesPerChunk</div><div class="line">                NSInteger numberOfEntriesRequired = newEntryIndex + 1;</div><div class="line">                NSInteger newChunkCount = _entriesPerChunk &gt; 0 ? ((numberOfEntriesRequired + _entriesPerChunk - 1) / _entriesPerChunk) : 0; </div><div class="line">                NSInteger newEntryCount = newChunkCount * _entriesPerChunk;</div><div class="line">                [self _setEntryCount:newEntryCount]; </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (newEntryIndex &lt; _entryCount) &#123;</div><div class="line">            CGSize pixelSize = [_imageFormat pixelSize];</div><div class="line">            CGBitmapInfo bitmapInfo = [_imageFormat bitmapInfo];</div><div class="line">            CGColorSpaceRef colorSpace = [_imageFormat isGrayscale] ? CGColorSpaceCreateDeviceGray() : CGColorSpaceCreateDeviceRGB();</div><div class="line">            NSInteger bitsPerComponent = [_imageFormat bitsPerComponent];</div><div class="line">            </div><div class="line">            // Create context whose backing store *is* the mapped file data</div><div class="line">            FICImageTableEntry *entryData = [self _entryDataAtIndex:newEntryIndex]; // 创建内存映射区域</div><div class="line">            if (entryData != nil) &#123;</div><div class="line">                [entryData setEntityUUIDBytes:FICUUIDBytesWithString(entityUUID)];</div><div class="line">                [entryData setSourceImageUUIDBytes:FICUUIDBytesWithString(sourceImageUUID)];</div><div class="line">                </div><div class="line">                // Update our book-keeping</div><div class="line">                _indexMap[entityUUID] = @((NSUInteger) newEntryIndex);</div><div class="line">                [_occupiedIndexes addIndex:(NSUInteger) newEntryIndex];</div><div class="line">                _sourceImageMap[entityUUID] = sourceImageUUID;</div><div class="line">                </div><div class="line">				 // 用于内存最近使用策略来装载和释放内存</div><div class="line">                [self _entryWasAccessedWithEntityUUID:entityUUID];</div><div class="line">                [self saveMetadata];</div><div class="line">                </div><div class="line">                // Unique, unchanging pointer for this entry&apos;s index</div><div class="line">                NSNumber *indexNumber = [self _numberForEntryAtIndex:newEntryIndex];</div><div class="line">                </div><div class="line">                // Relinquish the image table lock before calling potentially slow imageDrawingBlock to unblock other FIC operations</div><div class="line">                [_lock unlock];</div><div class="line">                // 利用创建位图，将图图象数据draw到位图当中，然后再保存位图字节数据</div><div class="line">                CGContextRef context = CGBitmapContextCreate([entryData bytes], (size_t) pixelSize.width, (size_t) pixelSize.height,</div><div class="line">                        (size_t) bitsPerComponent, (size_t) _imageRowLength, colorSpace, bitmapInfo);</div><div class="line">                </div><div class="line">                CGContextTranslateCTM(context, 0, pixelSize.height);</div><div class="line">                CGContextScaleCTM(context, _screenScale, -_screenScale);</div><div class="line">                </div><div class="line">                @synchronized(indexNumber) &#123;</div><div class="line">                    // Call drawing block to allow client to draw into the context</div><div class="line">                    // 解码</div><div class="line">                    imageDrawingBlock(context, [_imageFormat imageSize]);</div><div class="line">                    CGContextRelease(context);</div><div class="line">                </div><div class="line">                    // Write the data back to the filesystem</div><div class="line">                    [entryData flush];</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                [_lock unlock];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            CGColorSpaceRelease(colorSpace);</div><div class="line">        &#125; else &#123;</div><div class="line">            [_lock unlock];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里涉及到了递归锁，主要是防止多次调用lock造成死锁，有机会再次跟大家分享递归锁的神奇用法。</p>
<p>代码中-_entryDataAtIndex方法便创建了Chunk，但此时Chunk并没有数据，只是做了一个文件的映射区域。<br>利用-_indexOfEntryForEntityUUID创建了Entry， 分配了图像所需的字节和UUID等metaData所需的字节内存空间。然后我们使用-CGBitmapContextCreate利用内存空间创建位图，通过-imageDrawingBlock将图片字节全部draw到位图，然后通过Entry flush 就图像数据同步到磁盘当中， 这就完成了图片的存储了。</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>但是内存映射是不是就没有缺陷呢？<br>通过上文学习我们知道，内存映射是直接对应着虚拟内存区域的，也就是说是占用这我们虚拟内存的地址空间的，而且是一块常驻内存，那么当映射内存非常大的时候，甚至会影响我们程序的堆内存创建反而导致性能更差。所以 FastImageCahce 中甚至给Entry做了内存限制，一个Entry只能存储两M的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSInteger goalChunkLength = 2 * (1024 * 1024);</div><div class="line">NSInteger goalEntriesPerChunk = goalChunkLength / _entryLength;</div><div class="line">_entriesPerChunk = (NSUInteger) MAX(4, goalEntriesPerChunk); // 最少也要存在 4Entry/Chunk</div><div class="line">_chunkLength = (size_t)(_entryLength * _entriesPerChunk); // Chunk 的内存字节大小</div></pre></td></tr></table></figure>
<p>实际大小要跟着图像的大小改变，但是跟 2M 不会相差太多。</p>
<p>未完待续…(后续学到新方法，会持续更新)</p>
<p>通过上述方法，就能有效的加快我们图片的文件IO，特别当前我们的女性用户，手机里面有几十G图图片，当我们要做一个图片相册的精美应用的时候，这些性能便不可忽视了。根据摩尔定律，计算机性能约每隔18-24个月便会增加一倍，性能也将提升一倍，但是用户的要求和使用方式也会随着时间不断提高的！所以，平常培养对计算机原理的深入理解，才能写出高性能的代码，才不会在面对高并发高内存的情况下素手无策。</p>
<p><a href="https://simplecodesky.com/2018/04/10/ios-efficient-image-io/" target="_blank" rel="external">原文地址</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/项目技术总结/">项目技术总结</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS进阶/">iOS进阶</a><a href="/tags/iOS优化/">iOS优化</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://ixiaochuan.top/2018/04/13/iOS高效图片处理01/" data-title="iOS高效图片处理01_底层图片IO技术优化 | 小川的博客·iXiaoChuan" data-tsina="3051719850" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/05/01/iOS高效图片处理02/" title="iOS高效图片处理02_图片解码加载的性能探索">
  <strong>上一篇：</strong><br/>
  <span>
  iOS高效图片处理02_图片解码加载的性能探索</span>
</a>
</div>


<div class="next">
<a href="/2018/03/22/iOS开发中的单元测试/"  title="iOS开发中的单元测试">
 <strong>下一篇：</strong><br/> 
 <span>iOS开发中的单元测试
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2018/04/13/iOS高效图片处理01/" data-title="iOS高效图片处理01_底层图片IO技术优化" data-url="https://ixiaochuan.top/2018/04/13/iOS高效图片处理01/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#加载图片的底层操作原理"><span class="toc-number">1.</span> <span class="toc-text">加载图片的底层操作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化"><span class="toc-number">1.1.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件读取-资源消耗？"><span class="toc-number">2.</span> <span class="toc-text">文件读取,资源消耗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优化"><span class="toc-number">2.1.</span> <span class="toc-text">如何优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存在的问题"><span class="toc-number">2.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="iXiaoChuan" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS进阶/" title="iOS进阶">iOS进阶<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Python学习/" title="Python学习">Python学习<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS优化/" title="iOS优化">iOS优化<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Runloop/" title="Runloop">Runloop<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/单元测试/" title="单元测试">单元测试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/2019年度规划/" title="2019年度规划">2019年度规划<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/2018年度规划/" title="2018年度规划">2018年度规划<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/WKWebview/" title="WKWebview">WKWebview<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/博客阅读笔记/" title="博客阅读笔记">博客阅读笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Runtime/" title="Runtime">Runtime<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/属性/" title="属性">属性<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/2017年度规划/" title="2017年度规划">2017年度规划<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/蓝牙/" title="蓝牙">蓝牙<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://pingguohe.net" target="_blank" title="阿里技术团队">阿里技术团队</a>
            
          </li>
        
          <li>
            
            	<a href="https://tech.meituan.com" target="_blank" title="美团点评技术团队">美团点评技术团队</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.jianshu.com/p/49bc447cad19?from=timeline&isappinstalled=0" target="_blank" title="iOS各大技术团队博客汇总">iOS各大技术团队博客汇总</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" title="iOS前沿开发者_博客集">iOS前沿开发者_博客集</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/c/49bfa36740cc" target="_blank" title="iOS进阶指南_博客集">iOS进阶指南_博客集</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Welcome to XiaoChuan&#39;s blog~ <br/>
			@iXiaoChuan PersonalBlog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3051719850" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/iXiaoChuan" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/iXiaoChuan" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:xiaochuan171090331@outlook.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="iXiaoChuan">iXiaoChuan</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ixiaochuan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
