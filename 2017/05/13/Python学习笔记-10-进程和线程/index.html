
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Python学习笔记_10_进程和线程 | 小川的博客·iXiaoChuan</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="iXiaoChuan">
    

    
    <meta name="description" content="多进程
fork操作(Unix/Linux)Unix/Linux操作系统提供了一个fork()系统调用,它非常特殊.普通的函数调用,调用一次,返回一次,但是fork()调用一次,返回两次,因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程）,然后,分别在父进程和子进程内返回.子进程永远返回0,而父进程返回子进程的ID.这样做的理由是,一个父进程可以fork出很多子进程,所以,父进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记_10_进程和线程">
<meta property="og:url" content="https://ixiaochuan.top/2017/05/13/Python学习笔记-10-进程和线程/index.html">
<meta property="og:site_name" content="小川的博客·iXiaoChuan">
<meta property="og:description" content="多进程
fork操作(Unix/Linux)Unix/Linux操作系统提供了一个fork()系统调用,它非常特殊.普通的函数调用,调用一次,返回一次,但是fork()调用一次,返回两次,因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程）,然后,分别在父进程和子进程内返回.子进程永远返回0,而父进程返回子进程的ID.这样做的理由是,一个父进程可以fork出很多子进程,所以,父进程">
<meta property="og:updated_time" content="2018-07-09T01:58:57.879Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python学习笔记_10_进程和线程">
<meta name="twitter:description" content="多进程
fork操作(Unix/Linux)Unix/Linux操作系统提供了一个fork()系统调用,它非常特殊.普通的函数调用,调用一次,返回一次,但是fork()调用一次,返回两次,因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程）,然后,分别在父进程和子进程内返回.子进程永远返回0,而父进程返回子进程的ID.这样做的理由是,一个父进程可以fork出很多子进程,所以,父进程">

    
    <link rel="alternative" href="/atom.xml" title="小川的博客·iXiaoChuan" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="小川的博客·iXiaoChuan" title="小川的博客·iXiaoChuan"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="小川的博客·iXiaoChuan">小川的博客·iXiaoChuan</a></h1>
				<h2 class="blog-motto">零散知识整理、技术脉络总结、工作人生规划</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/usedapp">常用软件</a></li>
					
					<li>
 					
						<form class="search" action="http://ixiaochuan.top" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 10090999781559433000 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/13/Python学习笔记-10-进程和线程/" title="Python学习笔记_10_进程和线程" itemprop="url">Python学习笔记_10_进程和线程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="iXiaoChuan" target="_blank" itemprop="author">iXiaoChuan</a>
		
  <p class="article-time">
    <time datetime="2017-05-13T14:17:49.000Z" itemprop="datePublished"> 发表于 05-13-2017</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#多进程"><span class="toc-number">1.</span> <span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork操作-Unix-Linux"><span class="toc-number">1.1.</span> <span class="toc-text">fork操作(Unix/Linux)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing"><span class="toc-number">1.2.</span> <span class="toc-text">multiprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-number">1.3.</span> <span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子进程"><span class="toc-number">1.4.</span> <span class="toc-text">子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信"><span class="toc-number">1.5.</span> <span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">2.1.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多核CPU"><span class="toc-number">2.2.</span> <span class="toc-text">多核CPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-VS-线程"><span class="toc-number">4.</span> <span class="toc-text">进程 VS 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计算密集型-vs-IO密集型"><span class="toc-number">4.1.</span> <span class="toc-text">计算密集型 vs. IO密集型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步IO"><span class="toc-number">4.2.</span> <span class="toc-text">异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式进程"><span class="toc-number">5.</span> <span class="toc-text">分布式进程</span></a></li></ol>
		
		</div>
		
		<a id="more"></a>
<blockquote>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2></blockquote>
<h3 id="fork操作-Unix-Linux"><a href="#fork操作-Unix-Linux" class="headerlink" title="fork操作(Unix/Linux)"></a><font color="#3194d5" size="3">fork操作(Unix/Linux)</font></h3><p>Unix/Linux操作系统提供了一个fork()系统调用,它非常特殊.普通的函数调用,调用一次,返回一次,但是fork()调用一次,返回两次,因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程）,然后,分别在父进程和子进程内返回.<br><br>子进程永远返回0,而父进程返回子进程的ID.这样做的理由是,一个父进程可以fork出很多子进程,所以,父进程要记下每个子进程的ID,而子进程只需要调用getppid()就可以拿到父进程的ID.<br><br>有了fork调用,一个进程在接到新任务时就可以复制出一个子进程来处理新任务,常见的Apache服务器就是由父进程监听端口,每当有新的http请求时,就fork出子进程来处理新的http请求.</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a><font color="#3194d5" size="3">multiprocessing</font></h3><p>如果你打算编写多进程的服务程序,Unix/Linux无疑是正确的选择.由于Windows没有fork调用,难道在Windows上无法用Python编写多进程的程序？由于Python是跨平台的,自然也应该提供一个跨平台的多进程支持.multiprocessing模块就是跨平台版本的多进程模块.<br><br>示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 子进程要执行的代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</div><div class="line">    print(<span class="string">'Child process will start.'</span>)</div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    print(<span class="string">'Child process end.'</span>)</div></pre></td></tr></table></figure>
<p>创建子进程时,只需要传入一个执行函数和函数的参数,创建一个Process实例,用start()方法启动,这样创建进程比fork()还要简单.<br><br>join()方法可以等待子进程结束后再继续往下运行,通常用于进程间的同步.</p>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a><font color="#3194d5" size="3">pool</font></h3><p>如果要启动大量的子进程,可以用进程池的方式批量创建子进程,示例如下:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Pool</div><div class="line">import os, <span class="built_in">time</span>, <span class="built_in">random</span></div><div class="line"></div><div class="line">def long_time_task(name):</div><div class="line">    <span class="built_in">print</span>('Run task <span class="built_in">%s</span> (<span class="built_in">%s</span>)...' <span class="symbol">%</span> (name, os.getpid()))</div><div class="line">    start = <span class="built_in">time</span>.<span class="built_in">time</span>()</div><div class="line">    <span class="built_in">time</span>.sleep(<span class="built_in">random</span>.<span class="built_in">random</span>() * <span class="number">3</span>)</div><div class="line">    end = <span class="built_in">time</span>.<span class="built_in">time</span>()</div><div class="line">    <span class="built_in">print</span>('Task <span class="built_in">%s</span> runs <span class="symbol">%</span><span class="number">0.</span>2f seconds.' <span class="symbol">%</span> (name, (end - start)))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__=='__main__':</div><div class="line">    <span class="built_in">print</span>('Parent process <span class="built_in">%s</span>.' <span class="symbol">%</span> os.getpid())</div><div class="line">    p = Pool(<span class="number">4</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</div><div class="line">        p.apply_async(long_time_task, <span class="built_in">args</span>=(i,))</div><div class="line">    <span class="built_in">print</span>('Waiting <span class="keyword">for</span> all subprocesses done...')</div><div class="line">    p.<span class="built_in">close</span>()</div><div class="line">    p.<span class="built_in">join</span>()</div><div class="line">    <span class="built_in">print</span>('All subprocesses done.')</div></pre></td></tr></table></figure>
<p>对Pool对象调用join()方法会等待所有子进程执行完毕,调用join()之前必须先调用close(),调用close()之后就不能继续添加新的Process了.</p>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a><font color="#3194d5" size="3">子进程</font></h3><p>很多时候,子进程并不是自身,而是一个外部进程.我们创建了子进程后,还需要控制子进程的输入和输出.subprocess模块可以让我们非常方便地启动一个子进程,然后控制其输入和输出.</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><font color="#3194d5" size="3">进程间通信</font></h3><p>Process之间肯定是需要通信的,操作系统提供了很多机制来实现进程间的通信.Python的multiprocessing模块包装了底层的机制,提供了Queue、Pipes等多种方式来交换数据.示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</div><div class="line"><span class="keyword">import</span> os, time, random</div><div class="line"></div><div class="line"><span class="comment"># 写数据进程执行的代码:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></div><div class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</div><div class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</div><div class="line">        q.put(value)</div><div class="line">        time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="comment"># 读数据进程执行的代码:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></div><div class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        value = q.get(<span class="keyword">True</span>)</div><div class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># 父进程创建Queue,并传给各个子进程：</span></div><div class="line">    q = Queue()</div><div class="line">    pw = Process(target=write, args=(q,))</div><div class="line">    pr = Process(target=read, args=(q,))</div><div class="line">    <span class="comment"># 启动子进程pw,写入:</span></div><div class="line">    pw.start()</div><div class="line">    <span class="comment"># 启动子进程pr,读取:</span></div><div class="line">    pr.start()</div><div class="line">    <span class="comment"># 等待pw结束:</span></div><div class="line">    pw.join()</div><div class="line">    <span class="comment"># pr进程里是死循环,无法等待其结束,只能强行终止:</span></div><div class="line">    pr.terminate()</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2></blockquote>
<p>由于线程是操作系统直接支持的执行单元,因此,高级语言通常都内置多线程的支持,Python也不例外,并且,Python的线程是真正的Posix Thread,而不是模拟出来的线程.<br><br>Python的标准库提供了两个模块：_thread和threading,_thread是低级模块,threading是高级模块,对_thread进行了封装.绝大多数情况下,我们只需要使用threading这个高级模块.<br><br>启动一个线程就是把一个函数传入并创建Thread实例,然后调用start()开始执行.<br><br>由于任何进程默认就会启动一个线程,我们把该线程称为主线程,主线程又可以启动新的线程,Python的threading模块有个current_thread()函数,它永远返回当前线程的实例.主线程实例的名字叫MainThread,子线程的名字在创建时指定,我们用LoopThread命名子线程.名字仅仅在打印时用来显示,完全没有其他意义,如果不起名字Python就自动给线程命名为Thread-1,Thread-2……</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><font color="#3194d5" size="3">Lock</font></h3><p>多线程和多进程最大的不同在于,多进程中,同一个变量,各自有一份拷贝存在于每个进程中,互不影响,而多线程中,所有变量都由所有线程共享,所以,任何一个变量都可以被任何一个线程修改,因此,线程之间共享数据最大的危险在于多个线程同时改一个变量,把内容给改乱了.<br><br>当多个线程同时执行lock.acquire()时,只有一个线程能成功地获取锁,然后继续执行代码,其他线程就继续等待直到获得锁为止.<br><br>获得锁的线程用完后一定要释放锁,否则那些苦苦等待锁的线程将永远等待下去,成为死线程.所以我们用try…finally来确保锁一定会被释放.<br><br>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行,坏处当然也很多,首先是阻止了多线程并发执行,包含锁的某段代码实际上只能以单线程模式执行,效率就大大地下降了.其次,由于可以存在多个锁,不同的线程持有不同的锁,并试图获取对方持有的锁时,可能会造成死锁,导致多个线程全部挂起,既不能执行,也无法结束,只能靠操作系统强制终止.</p>
<h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a><font color="#3194d5" size="3">多核CPU</font></h3><p>启动与CPU核心数量相同的N个线程,在4核CPU上可以监控到CPU占用率仅有102%,也就是仅使用了一核.<br><br>但是用C、C++或Java来改写相同的死循环,直接可以把全部核心跑满,4核就跑到400%,8核就跑到800%,为什么Python不行呢？<br><br>因为Python的线程虽然是真正的线程,但解释器执行代码时,有一个GIL锁：Global Interpreter Lock,任何Python线程执行前,必须先获得GIL锁,然后,每执行100条字节码,解释器就自动释放GIL锁,让别的线程有机会执行.这个GIL全局锁实际上把所有线程的执行代码都给上了锁,所以,多线程在Python中只能交替执行,即使100个线程跑在100核CPU上,也只能用到1个核.<br><br>GIL是Python解释器设计的历史遗留问题,通常我们用的解释器是官方实现的CPython,要真正利用多核,除非重写一个不带GIL的解释器.<br><br>所以,在Python中,可以使用多线程,但不要指望能有效利用多核.如果一定要通过多线程利用多核,那只能通过C扩展来实现,不过这样就失去了Python简单易用的特点.<br><br>不过,也不用过于担心,Python虽然不能利用多线程实现多核任务,但可以通过多进程实现多核任务.多个Python进程有各自独立的GIL锁,互不影响<br></p>
<blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2></blockquote>
<p>在多线程环境下,每个线程都有自己的数据.一个线程使用自己的局部变量比使用全局变量好,因为局部变量只有线程自己能看见,不会影响其他线程,而全局变量的修改必须加锁.但是局部变量也有问题,就是在函数调用的时候,传递起来很麻烦.可以在本地建立一个dict,然后把对应线程需要操作的对象以该线程id为key放进去,在需要用到的函数里面直接根据当前线程id取出来使用即可,但是这种方式仍然存在弊端,就是存取dict的操作看起来非常突兀,比较杂乱.<br><br>所,这个时候ThreadLocal就应运而生了,不用查找dict,ThreadLocal帮你自动做这件事,示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></div><div class="line">local_school = threading.local()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 获取当前线程关联的student:</span></div><div class="line">    std = local_school.student</div><div class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></div><div class="line">    local_school.student = name</div><div class="line">    process_student()</div><div class="line"></div><div class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</div><div class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</div><div class="line">t1.start()</div><div class="line">t2.start()</div><div class="line">t1.join()</div><div class="line">t2.join()</div></pre></td></tr></table></figure>
<p>全局变量local_school就是一个ThreadLocal对象,每个Thread对它都可以读写student属性,但互不影响.你可以把local_school看成全局变量,但每个属性如local_school.student都是线程的局部变量,可以任意读写而互不干扰,也不用管理锁的问题,ThreadLocal内部会处理.<br><br>可以理解为全局变量local_school是一个dict,不但可以用local_school.student,还可以绑定其他变量,如local_school.teacher等等.<br><br>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接,HTTP请求,用户身份信息等,这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源.<br><br>一个ThreadLocal变量虽然是全局变量,但每个线程都只能读写自己线程的独立副本,互不干扰.ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题.</p>
<blockquote>
<h2 id="进程-VS-线程"><a href="#进程-VS-线程" class="headerlink" title="进程 VS 线程"></a>进程 VS 线程</h2></blockquote>
<p>首先,要实现多任务,通常我们会设计Master-Worker模式,Master负责分配任务,Worker负责执行任务,因此,多任务环境下,通常是一个Master,多个Worker.<br><br>如果用多进程实现Master-Worker,主进程就是Master,其他进程就是Worker.<br><br>如果用多线程实现Master-Worker,主线程就是Master,其他线程就是Worker.<br></p>
<p>无论是多进程还是多线程,只要数量一多,效率肯定上不去,为什么呢?因为系统调度进程切换也是需要资源的,需要保存当前的系统状态,然后调度系统给其他进程开辟新的资源,如果进程多到一定程度,系统资源全部都给调度进程使用了,就会使系统卡死,处于一种假死状态.</p>
<h3 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a><font color="#3194d5" size="2">计算密集型 vs. IO密集型</font></h3><p>计算密集型任务的特点是要进行大量的计算,消耗CPU资源,比如计算圆周率、对视频进行高清解码等等,全靠CPU的运算能力.这种计算密集型任务虽然也可以用多任务完成,但是任务越多,花在任务切换的时间就越多,CPU执行任务的效率就越低,所以,要最高效地利用CPU,计算密集型任务同时进行的数量应当等于CPU的核心数.<br></p>
<p>计算密集型任务由于主要消耗CPU资源,因此,代码运行效率至关重要.Python这样的脚本语言运行效率很低,完全不适合计算密集型任务.对于计算密集型任务,最好用C语言编写.<br></p>
<p>第二种任务的类型是IO密集型,涉及到网络、磁盘IO的任务都是IO密集型任务,这类任务的特点是CPU消耗很少,任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）.对于IO密集型任务,任务越多,CPU效率越高,但也有一个限度.常见的大部分任务都是IO密集型任务,比如Web应用.<br></p>
<p>IO密集型任务执行期间,99%的时间都花在IO上,花在CPU上的时间很少,因此,用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言,完全无法提升运行效率.对于IO密集型任务,最合适的语言就是开发效率最高（代码量最少）的语言,脚本语言是首选,C语言最差.<br></p>
<p>考虑到CPU和IO之间巨大的速度差异,一个任务在执行的过程中大部分时间都在等待IO操作,单进程单线程模型会导致别的任务无法并行执行,因此,我们才需要多进程模型或者多线程模型来支持多任务并发执行.</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><font color="#3194d5" size="2">异步IO</font></h3><p>现代操作系统对IO操作已经做了巨大的改进,最大的特点就是支持异步IO.如果充分利用操作系统提供的异步IO支持,就可以用单进程单线程模型来执行多任务,这种全新的模型称为事件驱动模型,Nginx就是支持异步IO的Web服务器,它在单核CPU上采用单进程模型就可以高效地支持多任务.在多核CPU上,可以运行多个进程（数量与CPU核心数相同）,充分利用多核CPU.由于系统总的进程数量十分有限,因此操作系统调度非常高效.用异步IO编程模型来实现多任务是一个主要的趋势.</p>
<p>对应到Python语言,单线程的异步编程模型称为协程,有了协程的支持,就可以基于事件驱动编写高效的多任务程序.</p>
<blockquote>
<h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2></blockquote>
<p>在Thread和Process中,应当优选Process,因为Process更稳定,而且,Process可以分布到多台机器上,而Thread最多只能分布到同一台机器的多个CPU上.</p>
<p>Python的multiprocessing模块不但支持多进程,其中managers子模块还支持把多进程分布到多台机器上.一个服务进程可以作为调度者,将任务分布到其他多个进程中,依靠网络通信.由于managers模块封装很好,不必了解网络通信的细节,就可以很容易地编写分布式多进程程序.</p>
<p>举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行,现在,由于处理任务的进程任务繁重,希望把发送任务的进程和处理任务的进程分布到两台机器上.怎么用分布式进程实现？</p>
<p>原有的Queue可以继续使用,但是,通过managers模块把Queue通过网络暴露出去,就可以让其他机器的进程访问Queue了.</p>
<p>我们先看服务进程,服务进程负责启动Queue,把Queue注册到网络上,然后往Queue里面写入任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># task_master.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random, time, queue</div><div class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</div><div class="line"></div><div class="line"><span class="comment"># 发送任务的队列:</span></div><div class="line">task_queue = queue.Queue()</div><div class="line"><span class="comment"># 接收结果的队列:</span></div><div class="line">result_queue = queue.Queue()</div><div class="line"></div><div class="line"><span class="comment"># 从BaseManager继承的QueueManager:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></div><div class="line">QueueManager.register(<span class="string">'get_task_queue'</span>, callable=<span class="keyword">lambda</span>: task_queue)</div><div class="line">QueueManager.register(<span class="string">'get_result_queue'</span>, callable=<span class="keyword">lambda</span>: result_queue)</div><div class="line"><span class="comment"># 绑定端口5000, 设置验证码'abc':</span></div><div class="line">manager = QueueManager(address=(<span class="string">''</span>, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</div><div class="line"><span class="comment"># 启动Queue:</span></div><div class="line">manager.start()</div><div class="line"><span class="comment"># 获得通过网络访问的Queue对象:</span></div><div class="line">task = manager.get_task_queue()</div><div class="line">result = manager.get_result_queue()</div><div class="line"><span class="comment"># 放几个任务进去:</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    n = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</div><div class="line">    print(<span class="string">'Put task %d...'</span> % n)</div><div class="line">    task.put(n)</div><div class="line"><span class="comment"># 从result队列读取结果:</span></div><div class="line">print(<span class="string">'Try get results...'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    r = result.get(timeout=<span class="number">10</span>)</div><div class="line">    print(<span class="string">'Result: %s'</span> % r)</div><div class="line"><span class="comment"># 关闭:</span></div><div class="line">manager.shutdown()</div><div class="line">print(<span class="string">'master exit.'</span>)</div></pre></td></tr></table></figure>
<p>请注意,当我们在一台机器上写多进程程序时,创建的Queue可以直接拿来用,但是,在分布式多进程环境下,添加任务到Queue不可以直接对原始的task_queue进行操作,那样就绕过了QueueManager的封装,必须通过manager.get_task_queue()获得的Queue接口添加.</p>
<p>然后,在另一台机器上启动任务进程（本机上启动也可以）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># task_master.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random,time,queue</div><div class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 发送任务的队列</span></div><div class="line">task_queue = queue.Queue()</div><div class="line"><span class="comment"># 接受结果的队列</span></div><div class="line">result_queue = queue.Queue()</div><div class="line"><span class="comment"># 从baseManager继承的QueueManager:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line">                                                                                                                      </div><div class="line"><span class="comment"># 把两个Queue都注册到网络上,callable参数关联了Queue对象:</span></div><div class="line">QueueManager.register(<span class="string">'get_task_queue'</span>,callable=<span class="keyword">lambda</span> : task_queue)</div><div class="line">QueueManager.register(<span class="string">'get_result_queue'</span>,callable=<span class="keyword">lambda</span> : result_queue)</div><div class="line"><span class="comment"># 绑定端口50000,设置验证码'abc'</span></div><div class="line">manager = QueueManager(address=(<span class="string">'127.0.0.1'</span>,<span class="number">5000</span>),authkey=<span class="string">b'abc'</span>)</div><div class="line"><span class="comment"># 启动Queue:</span></div><div class="line">manager.start()</div><div class="line"><span class="comment"># 获取通过网路访问的Queue对象:</span></div><div class="line">task = manager.get_task_queue()</div><div class="line">result = manager.get_result_queue()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 放几个任务进去:</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    n = random.randint(<span class="number">0</span>,<span class="number">10000</span>)</div><div class="line">    print(<span class="string">'Put task %d...'</span> % n)</div><div class="line">    task.put(n)</div><div class="line"></div><div class="line"><span class="comment"># 从Result队列读取结果:</span></div><div class="line">print(<span class="string">'Try get results...'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        r = result.get(timeout=<span class="number">100</span>)</div><div class="line">        print(<span class="string">'Result: %s'</span> % r)</div><div class="line">    <span class="keyword">except</span> Queue.Empty:</div><div class="line">        print(<span class="string">'Get nothing.'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 关闭</span></div><div class="line">manager.shutdown()</div><div class="line">print(<span class="string">'Manager exit.'</span>)</div></pre></td></tr></table></figure>
<p>然后,在另一台机器上启动任务进程（本机上启动也可以）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># task_worker.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time, sys, queue</div><div class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</div><div class="line"></div><div class="line"><span class="comment"># 创建类似的queueManager</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManger</span><span class="params">(BaseManager)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 由于这个QueueManager只能从网络上获取Queue,所以注册时只提供名字:</span></div><div class="line">QueueManger.register(<span class="string">'get_task_queue'</span>)</div><div class="line">QueueManger.register(<span class="string">'get_result_queue'</span>)</div><div class="line"><span class="comment"># 链接到服务,也就是运行task_master.py的机器:</span></div><div class="line">server_addr = <span class="string">'127.0.0.1'</span></div><div class="line">print(<span class="string">'Work Connect to server: %s...'</span> % server_addr)</div><div class="line"><span class="comment"># 端口验证码注意保持与task_master.py设置的完全一致:</span></div><div class="line">manager = QueueManger(address=(server_addr, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</div><div class="line"><span class="comment"># 从网络连接:</span></div><div class="line">manager.connect()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 获取Queue的对象:</span></div><div class="line">task = manager.get_task_queue()</div><div class="line">result = manager.get_result_queue()</div><div class="line"></div><div class="line"><span class="comment"># 从task队列取任务,并且把结果写入Reuslt队列</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        n = task.get(timeout=<span class="number">2</span>)</div><div class="line">        print(<span class="string">'Work Run task %d * %d'</span> % (n,n))</div><div class="line">        r = <span class="string">'%d * %d = %d'</span> % (n,n,n*n)</div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line">        result.put(r)</div><div class="line">    <span class="keyword">except</span> Queue.empty:</div><div class="line">        print(<span class="string">'Task queue is empty.'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 处理结束</span></div><div class="line">print(<span class="string">'Worker exit.'</span>)</div></pre></td></tr></table></figure>
<p>先运行Master任务分发进程,然后启动worker任务处理进程(这个处理进程可以是多个,在多个设备上).</p>
<p>Python的分布式进程接口简单,封装良好,适合需要把繁重任务分布到多台机器的环境下.</p>
<p>注意Queue的作用是用来传递任务和接收结果,每个任务的描述数据量要尽量小.比如发送一个处理日志文件的任务,就不要发送几百兆的日志文件本身,而是发送日志文件存放的完整路径,由Worker进程再去共享的磁盘上读取文件.</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Python学习/">Python学习</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://ixiaochuan.top/2017/05/13/Python学习笔记-10-进程和线程/" data-title="Python学习笔记_10_进程和线程 | 小川的博客·iXiaoChuan" data-tsina="3051719850" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/06/04/Python学习笔记-11-正则表达式/" title="Python学习笔记_11_正则表达式">
  <strong>上一篇：</strong><br/>
  <span>
  Python学习笔记_11_正则表达式</span>
</a>
</div>


<div class="next">
<a href="/2017/04/29/Python学习笔记-09-IO编程/"  title="Python学习笔记_09_IO编程">
 <strong>下一篇：</strong><br/> 
 <span>Python学习笔记_09_IO编程
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2017/05/13/Python学习笔记-10-进程和线程/" data-title="Python学习笔记_10_进程和线程" data-url="https://ixiaochuan.top/2017/05/13/Python学习笔记-10-进程和线程/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#多进程"><span class="toc-number">1.</span> <span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork操作-Unix-Linux"><span class="toc-number">1.1.</span> <span class="toc-text">fork操作(Unix/Linux)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing"><span class="toc-number">1.2.</span> <span class="toc-text">multiprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-number">1.3.</span> <span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子进程"><span class="toc-number">1.4.</span> <span class="toc-text">子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信"><span class="toc-number">1.5.</span> <span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">2.1.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多核CPU"><span class="toc-number">2.2.</span> <span class="toc-text">多核CPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-VS-线程"><span class="toc-number">4.</span> <span class="toc-text">进程 VS 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计算密集型-vs-IO密集型"><span class="toc-number">4.1.</span> <span class="toc-text">计算密集型 vs. IO密集型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步IO"><span class="toc-number">4.2.</span> <span class="toc-text">异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式进程"><span class="toc-number">5.</span> <span class="toc-text">分布式进程</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="iXiaoChuan" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS进阶/" title="iOS进阶">iOS进阶<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Python学习/" title="Python学习">Python学习<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS优化/" title="iOS优化">iOS优化<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/WKWebview/" title="WKWebview">WKWebview<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Runtime/" title="Runtime">Runtime<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/2017年度规划/" title="2017年度规划">2017年度规划<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/2018年度规划/" title="2018年度规划">2018年度规划<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/单元测试/" title="单元测试">单元测试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/博客阅读笔记/" title="博客阅读笔记">博客阅读笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/蓝牙/" title="蓝牙">蓝牙<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Runloop/" title="Runloop">Runloop<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/属性/" title="属性">属性<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://pingguohe.net" target="_blank" title="阿里技术团队">阿里技术团队</a>
            
          </li>
        
          <li>
            
            	<a href="https://tech.meituan.com" target="_blank" title="美团点评技术团队">美团点评技术团队</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.jianshu.com/p/49bc447cad19?from=timeline&isappinstalled=0" target="_blank" title="iOS各大技术团队博客汇总">iOS各大技术团队博客汇总</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" title="iOS前沿开发者_博客集">iOS前沿开发者_博客集</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/c/49bfa36740cc" target="_blank" title="iOS进阶指南_博客集">iOS进阶指南_博客集</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Welcome to XiaoChuan&#39;s blog~ <br/>
			@iXiaoChuan PersonalBlog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3051719850" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/iXiaoChuan" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/iXiaoChuan" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:xiaochuan171090331@outlook.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="iXiaoChuan">iXiaoChuan</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ixiaochuan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
